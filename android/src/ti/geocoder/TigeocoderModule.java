/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package ti.geocoder;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;

import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.titanium.TiApplication;
import org.appcelerator.titanium.TiC;
import org.appcelerator.titanium.util.TiConvert;
import org.appcelerator.kroll.common.Log;

import android.location.Address;
import android.location.Criteria;
import android.location.Geocoder;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Bundle;


@Kroll.module(name="Tigeocoder", id="ti.geocoder")
public class TigeocoderModule extends KrollModule
{
	// Standard Debugging variables
	public static final String MODULE_FULL_NAME = "Ti.Geocoder";
	public static boolean DEBUG = false;
	private static int ForwardResultsLimit=1;
	private static int ReverseResultsLimit=1;
	private Locale currentLocale = Locale.getDefault(); 
	
	// You can define constants with @Kroll.constant, for example:
	// @Kroll.constant public static final String EXTERNAL_NAME = value;

	public TigeocoderModule()
	{
		super();
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app){}

	@Kroll.method
	public void setGeoLocale(Object[] args){
		final int kArgLanguage = 0;
		final int kArgCount = 1;
		
		// Validate correct number of arguments
		if (args.length < kArgCount) {
			throw new IllegalArgumentException("one argument language is required");
		}
				
		// Use the TiConvert methods to get the values from the arguments
		String language = TiConvert.toString(args[kArgLanguage]);		
		currentLocale= new Locale(language);
		CommonHelpers.DebugLog("Locale is now " + currentLocale.toString());
	}
	@Kroll.method
	public boolean isSupported(){		
		return CommonHelpers.reverseGeoSupported();
	}


	@Kroll.method
	public void forwardGeocoderResultsLimit(Object[] args)
	{
		ForwardResultsLimit = (args[0] != null) ? TiConvert.toInt(args[0]) : 1;
	}
	@Kroll.method
	public void forwardGeocoder(Object[] args)
	{
		final int kArgAddress = 0;
		final int kArgCallback = 1;
		final int kArgCount = 2;
		
		// Validate correct number of arguments
		if (args.length < kArgCount) {
			throw new IllegalArgumentException("At least 2 arguments required for method: address and a callback");
		}	
		// Use the TiConvert methods to get the values from the arguments
		String findAddress = (args[kArgAddress] != null) ? TiConvert.toString(args[kArgAddress]) : "";
		KrollFunction callback = null;
		Object object = args[kArgCallback];
		if (object instanceof KrollFunction) {
			callback = (KrollFunction)object;
		}		

		Geocoder geocoder = new Geocoder(TiApplication.getInstance().getApplicationContext(), currentLocale);
        try {      		
      	 
            List<Address> list = geocoder.getFromLocationName(findAddress,ForwardResultsLimit);
            int placeCount = list.size();
            Object[] addressResult = new Object[placeCount];
            if (list != null && placeCount > 0) {            	  
	          	  for (int iLoop = 0; iLoop < placeCount; iLoop++) {
	          			addressResult[iLoop]=CommonHelpers.buildAddress(list.get(iLoop));
	          		}
            }
    		  if (callback != null) {      				
	      			HashMap<String, Object> eventOk = new HashMap<String, Object>();
	      			eventOk.put("placeCount",placeCount);
	      			eventOk.put("places",addressResult);
	      			eventOk.put("success",true);	
	    			callback.call(getKrollObject(), eventOk);
    		  }              
    		  CommonHelpers.DebugLog("[FORWARDGEO] was successful");
        } catch (IOException e) {
    		  if (callback != null) {      				
	      			HashMap<String, Object> eventErr = new HashMap<String, Object>();
	      			eventErr.put("placeCount",0);
	      			eventErr.put("success",false);
	      			eventErr.put("message",e.getMessage());	
	    			callback.call(getKrollObject(), eventErr);
    		  }       
    		  CommonHelpers.DebugLog("[FORWARDGEO] Geocoder error");
    		  CommonHelpers.Log(e);
        } finally {
      	  geocoder=null;
        } 		
	}
	@Kroll.method
	public void ReverseGeocoderResultsLimit(Object[] args)
	{
		ReverseResultsLimit = (args[0] != null) ? TiConvert.toInt(args[0]) : 1;
	}
	@Kroll.method
	public void reverseGeocoder(Object[] args)
	{
		final int kArgLatitude = 0;
		final int kArgLongitude = 1;
		final int kArgCallback = 2;
		final int kArgCount = 3;
		
		// Validate correct number of arguments
		if (args.length < kArgCount) {
			throw new IllegalArgumentException("At least 3 arguments required for method: latitude, longitude, and a callback");
		}	
		// Use the TiConvert methods to get the values from the arguments
		double latitude = (args[kArgLatitude] != null) ? TiConvert.toDouble(args[kArgLatitude]) : 0;
		double longitude = (args[kArgLongitude] != null) ? TiConvert.toDouble(args[kArgLongitude]) : 0;
		KrollFunction callback = null;
		Object object = args[kArgCallback];
		if (object instanceof KrollFunction) {
			callback = (KrollFunction)object;
		}
		
	      Geocoder geocoder = new Geocoder(TiApplication.getInstance().getApplicationContext(), currentLocale);   
          try {          	 
              List<Address> list = geocoder.getFromLocation(latitude,longitude,ReverseResultsLimit);
              int placeCount = list.size();
              Object[] addressResult = new Object[placeCount];
              if (list != null && placeCount > 0) {            	  
	          	  for (int iLoop = 0; iLoop < placeCount; iLoop++) {
	          		addressResult[iLoop]= CommonHelpers.buildAddress(latitude,longitude,list.get(iLoop));
	          		}
              }
      		  if (callback != null) {      				
	      			HashMap<String, Object> eventOk = new HashMap<String, Object>();
	      			eventOk.put("placeCount",placeCount);
	      			eventOk.put("places",addressResult);
	      			eventOk.put("success",true);	
	    			callback.call(getKrollObject(), eventOk);
      		  }   
      		CommonHelpers.DebugLog("[REVERSEGEO] was successful");
          } catch (IOException e) {
      		  if (callback != null) {      				
	      			HashMap<String, Object> eventErr = new HashMap<String, Object>();
	      			eventErr.put("placeCount",0);
	      			eventErr.put("success",false);	
	      			eventErr.put("latitude",latitude);
	      			eventErr.put("longitude",longitude);
	      			eventErr.put("message", e.getMessage());
	    			callback.call(getKrollObject(), eventErr);
	    			CommonHelpers.DebugLog("[REVERSEGEO] callback error called");
      		  }          	
              Log.e(MODULE_FULL_NAME, "[REVERSEGEO] Geocoder error for lat:" + latitude +" lng:" + longitude, e);
          } finally {
        	  geocoder=null;
          }        
	}

	private HashMap<String, Object> FindAddress(double latitude, double longitude,String providerName){
	      Geocoder geocoder = new Geocoder(TiApplication.getInstance().getApplicationContext(), currentLocale);   
	      
	      try {            
	    	  List<Address> list = geocoder.getFromLocation(latitude,longitude,1);            
	    	  int placeCount = list.size();            
	    	  Object[] addressResult = new Object[placeCount];            
	    	  if (list != null && placeCount > 0) {            	  	          
	    		  for (int iLoop = 0; iLoop < placeCount; iLoop++) {	          		
	    			  addressResult[iLoop]= CommonHelpers.buildAddress(latitude,longitude,list.get(iLoop));	          		
	    		  }
	    	  }

	    	CommonHelpers.DebugLog("[FIND ADDRESS] was successful");
          HashMap<String, Object> eventOk = new HashMap<String, Object>();
	      	eventOk.put("placeCount",placeCount);
	      	eventOk.put("places",addressResult);
	      	eventOk.put(TiC.PROPERTY_SUCCESS, true);	
	      	eventOk.put("locationProvider", providerName);
	      	return eventOk;
	      		
      } catch (IOException e) {
      	Log.e(MODULE_FULL_NAME, "[FIND ADDRESS] Error:",e);  				
			HashMap<String, Object> eventErr = new HashMap<String, Object>();
			eventErr.put("placeCount",0);
			eventErr.put(TiC.PROPERTY_SUCCESS, false);
			return eventErr;
      } finally {
    	  geocoder=null;
      } 		
	}
	@Kroll.method
	public void getCurrentPlace(KrollFunction inputcallback, @Kroll.argument(optional=true) CriteriaProxy criteriaproxy){	
		
		final KrollFunction callback = inputcallback;		
		Location cacheLocation = null;
		
		if(criteriaproxy == null){
			criteriaproxy = new CriteriaProxy();
		}
			
		if(!CommonHelpers.reverseGeoSupported()){
	  		  if (callback != null) {      				
	    			HashMap<String, Object> eventErr = new HashMap<String, Object>();
	    			eventErr.put("placeCount",0);
	    			eventErr.put(TiC.PROPERTY_SUCCESS, false);
	    			eventErr.put("message","Reverse Geo Location is not supported, see console for details");	
	    			callback.call(getKrollObject(), eventErr);
			  }         	
	  		  return;		
		}
			    
		if (!CommonHelpers.hasProviders()) {		  
			if (callback != null) {      				
    			HashMap<String, Object> eventErr = new HashMap<String, Object>();
    			eventErr.put("placeCount",0);
    			eventErr.put(TiC.PROPERTY_SUCCESS, false);
    			eventErr.put("message","No Location Providers available");	
    			callback.call(getKrollObject(), eventErr);			
			}         	
	      	return;	      
		}
      
	    LocationManager locManager = (LocationManager) TiApplication.getInstance().getApplicationContext().getSystemService(TiApplication.LOCATION_SERVICE);
				      
	    if(criteriaproxy.getUseCache()){
	    	cacheLocation = new CommonHelpers().getLastBestLocation(locManager,criteriaproxy.getCacheDistance(), criteriaproxy.getCacheTime());
	    }
	    if(cacheLocation!=null){
	    	callback.call(getKrollObject(), FindAddress(cacheLocation.getLatitude(),cacheLocation.getLongitude(),"lastFound"));
      		return;
	    }
	    
	    Criteria criteria = criteriaproxy.getCriteria();  	  
		String provider = locManager.getBestProvider(criteria, true);
		
		if(CommonHelpers.providerEmpty(provider)){
	  		if (callback != null) {      				
	  			HashMap<String, Object> eventErr = new HashMap<String, Object>();
				eventErr.put("placeCount",0);
				eventErr.put(TiC.PROPERTY_SUCCESS, false);
				eventErr.put("message","No Location Providers available");	
				callback.call(getKrollObject(), eventErr);
	  		} 
	  		return;
		}
		locManager.requestSingleUpdate(criteria, new LocationListener(){
	
	  	        @Override
	  	        public void onLocationChanged(Location location) {
	  	            	          	        	
	  				CommonHelpers.DebugLog("[ADDRESS SEARCH] onLocationChanged");
	  				
	  		        if(location==null){
		  			  		  if (callback != null) {      				
		  			    			HashMap<String, Object> eventErr = new HashMap<String, Object>();
		  			    			eventErr.put("placeCount",0);
		  			    			eventErr.put(TiC.PROPERTY_SUCCESS, false);
		  			    			eventErr.put("message","No Location Provided");	
		  			    			callback.call(getKrollObject(), eventErr);
		  					  }       	
		  		        }else{
		  		        	callback.call(getKrollObject(), FindAddress(location.getLatitude(),location.getLongitude(),location.getProvider()));	        	
		  		        }  
	
	  	        }
	
	  	        @Override
	  	        public void onProviderDisabled(String provider) {}
	  	        @Override
	  	        public void onProviderEnabled(String provider) {}
	  	        @Override
	  	        public void onStatusChanged(String provider, int status, Bundle extras) {}
	
	  	    }, null);  	
	}	
}

